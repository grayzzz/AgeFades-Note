# 面试整理

## 概述

```shell
# 此篇没有顺序目录。

# 记录 AgeFades 接触到的面试题目及引发的思考。
```

## MySQL

### 索引篇

#### 为什么使用 B+ Tree 作为索引的数据结构

```shell
# MySQL 为什么使用 B+ Tree 作为存储索引数据的数据结构？

# 因为对数据的存储就是使用到了数据结构。

	# 首先，索引就是 KV 键值对，K 为索引的值，V 为数据所在磁盘的偏移位置。
	
	# 假设: 使用二叉树来存储索引，最坏的情况下二叉树变成了单链表，
		# 索引数据就会造成覆盖磁盘 IO，有多少条数据就做了多少次磁盘 IO
	
	# 假设: 使用红黑树来存储索引，其实就是在二叉树的基础上增加了自旋平衡机制，
		# 自旋平衡机制就是左右子树的高度差 > 2，就会触发自旋调整树的高度。
		# 那么最坏情况下，就是做了 数据数量 / 2 的磁盘 IO
		# 所以决定索引次数的关键，就在于树的高度。
		
	# 那么 B+ Tree，就是在单个节点中，尽可能存储多的索引数据，
		# 降低了树的高度，就是减少了索引查找的次数，就是降低了磁盘 IO 的次数
		# SQL 查询数据响应就会更快。
```

##### B-Tree

![UTOOLS1583303110064.png](http://yanxuan.nosdn.127.net/b0d2fae86c7493b1f5871dc4044a455e.png)

```shell
# 叶节点具有相同的深度，叶节点的指针为空

# 所有索引元素不重复

# 节点中的数据索引从左到右递增排序
```

##### B-Tree 和 B+Tree 的选择

```shell
# 前文所述，树的深度越小，将索引数据从磁盘 IO 读取到内存中的 IO 次数就越少。

# 那是不是树的高度为 1 最好呢？
	# 这是硬件问题造成的，内存只有那么大，一次读取上千万条数据到内存中是不可能的
	# 在计算机的组成中，内存与磁盘的交互一般来说都只有4k 或者 4k 的整数倍几十k
	# 而 MySQL 对一次索引 IO 读取到内存中的设置为 16k
	# SHOW GLOBAL STATUS LIKE 'Innodb_page_size';
	
# 所以 MySQL 对 B-Tree 做了改造得到 B+Tree
```

##### B+Tree ![UTOOLS1583303788937.png](http://yanxuan.nosdn.127.net/b03923ad19def93e6f671995c51f4cbe.png)

```shell
# 非叶子节点不存储 data(索引所在行的磁盘位置)，只存储索引(冗余)，可以放更多的索引

# 叶子节点包含所有索引字段

# 叶子节点用指针连接，提高区间访问的性能

# 根据 MySQL 的设定，一个索引节点大小为 16KB
	# 假设 B+Tree 的高度为3
	# 每个索引数据占8个byte，加上中间向下的指针6个byte
	# 第一级就可以放1170 个索引元素，第二级就是 1170 * 1170 个索引元素
	# 到第三级叶子节点，加上索引指向的 data 数据，大约每个索引元素占 1kb
	# 一个节点就可以存放 16个索引元素，所以 1170 * 1170 * 16
	# 大约就是所有叶子节点存储的索引表数据，大约2000多万条数据。
	
# 所以在千万级数据表中，如果不对查询条件的字段添加索引，
	# 就是千万次 IO 和 个位数次 IO 的对比。
```

##### B+Tree 与 Hash 的选择

![UTOOLS1583808278259.png](http://yanxuan.nosdn.127.net/8986d2c44c07d6b273ac76c5edebeed8.png)

```shell
# MySQL 提供了 Hash 索引与 B树 索引。
	
# MySQL 对 Hash 算法优化的很好，最大可能避免了哈希冲撞，用 where = 查询速度比 B树快

# 为什么不用 Hash，是因为Hash 没办法解决区间查询索引，而 B+Tree 解决了这个问题
```

#### MyISAM 存储引擎索引实现解析

![UTOOLS1583305202090.png](http://yanxuan.nosdn.127.net/06c73cc8fb757c68067cb1c6c3ec055a.png)

```shell
# MySQL 可视化软件中的数据库，都对应着 MySQL 目录下的 data 目录，
	# 一个库对应一个文件夹
```

![UTOOLS1583305332436.png](http://yanxuan.nosdn.127.net/c9e7195d054c4ca8e4b157b769a4ef3d.png)

```shell
# MyISAM 索引文件和数据文件是分离的（非聚集）
	# 数据在 MYD 文件中
	# 索引在 MYI 文件中

# 存储引擎是针对 表 级别的。
```

![UTOOLS1583305533054.png](http://yanxuan.nosdn.127.net/5d08e1375a69058145329f3735f606e0.png)

```shell
# MyISAM 引擎表对应的是三个文件
	# frm : 该文件存储的是表的结构信息
	
	# MYD : 该文件存储的是表的数据行的记录信息
	
	# MYI : 该文件存储的是表的索引字段信息
```

#### InnoDB 存储引擎索引实现

![UTOOLS1583306060316.png](http://yanxuan.nosdn.127.net/569c7b109fa7706504232a71ad8a8df7.png)

```shell
# InnoDB 索引实现(聚集)
	# 表数据文件本身就是按 B+Tree 组织的一个索引结构文件
	# 聚集索引-叶子节点包含了完整的数据记录
	
# 为什么 InnoDB 表必须有主键，并且推荐使用整型的自增主键？
	# 在主键索引结构中，叶子节点的 data 数据即完整的数据行记录
	# 聚集索引就是: 叶子节点中 data 为完整的数据行记录
	# 推荐整型: 是因为 B+Tree 中索引的比较大小方便，利于二分查找
		# 从存储空间来说，整型较小，一次可以加载更多的主键数据
		
	# 推荐自增: 往索引结构中添加数据时便于区间排序，
		# 契合 B+Tree 叶子节点的区间指针，利于快速区间范围查找

# 为什么非主键索引结构叶子节点存储的是主键值？(一致性和节省存储空间)
	# 因为 InnoDB 中数据和索引是在同一个文件中
	# 非主键索引的叶子节点 data 指向主键
	# 再由找到的主键去主键索引中找到最终对应的数据行记录
```

![UTOOLS1583308082734.png](http://yanxuan.nosdn.127.net/a8772efb0aba434117f22720d02c6e57.png)

```shell
# InnoDB 引擎的表只有两个文件
	# frm : 存储表的结构信息
	
	# ibd : 存储表的数据和索引
```

#### 联合索引的底层存储结构

![UTOOLS1583984777876.png](http://yanxuan.nosdn.127.net/8eee706e1aa5afca80b864901b621eb9.png)



